<!DOCTYPE html>
<html>

  <head>
    <style type="text/css">
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
      }

      .full-size {
        height: 100%;
        width: 100%;
        overflow: hidden;
        /* or overflow:auto; if you want scrollbars */
      }

      #main {
        background-color: black;
      }

      .line {
        width: 50px;
        height: 2px;
        background-color: white;
        /* background: linear-gradient(90deg, red 50%, blue 50%); */
        position: fixed;
        top: 0px;
        left: -25px;
        overflow: hidden;
        transform: rotate(25deg)
      }

      .hit {
        position: fixed;
        height: 10px;
        width: 10px;
        background-color: green;
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }

      .dot {
        position: fixed;
        height: 10px;
        width: 10px;
        background-color: pink;
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }

    </style>
    <link rel="manifest" href="/windmill/manifest.json">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="ms-icon-144x144.png">

    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Windmill">
    <meta name="apple-mobile-web-app-title" content="Windmill">
    <meta name="theme-color" content="#FF69B4">
    <meta name="msapplication-navbutton-color" content="#FF69B4">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-starturl" content="/windmill">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta charset="utf-8">
    <title>Windmill Simulation</title>
  </head>

  <body>

    <div id="main" class="full-size">
      <div class="line"></div>
    </div>

    <script type="text/javascript">
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/windmill/service-worker.js');
      }


      const floor = num => num << 0;
      const str2num = str => parseInt(str.slice(0, -2));
      const vw = window.innerWidth || 2000;
      const vh = window.innerHeight || 2000;
      const len = 3 * (vh + vw);
      const dots = {};
      const getpos = (elm) => {
        const rect = elm.getBoundingClientRect();
        const x = str2num(elm.style.left) + floor(len / 2);
        const y = str2num(elm.style.top);
        return {
          x,
          y
        };
      }
      const setpos = (elm, x, y) => {
        elm.style.left = `${x - floor(len / 2)}px`;
        elm.style.top = `${y}px`
      }
      const universe = document.querySelector('#main');
      const line = document.querySelector('.line');
      line.style['width'] = `${len}px`;
      line.style['left'] = '0px';
      line.style['top'] = '0px';
      line.style['overflow'] = 'hidden';
      getpos(line);
      setpos(line, floor(vw / 2), floor(vh / 2));
      //setpos(line,0,0);

      getpos(line);


      var start = null;
      var slope = 0;
      var shouldUseislope = false;
      var nextDot;
      var nextDotDeg = 365;
      var digs = [];
      var curDot;

      var tic = 0;

      function doStuff() {

        let islope = slope + 180;
        if (islope < 0) {
          islope = 360 + islope;
        } else if (islope > 360) {
          islope = islope - 360;
        }
        const tryslope = shouldUseislope ? islope : slope;
        const linebuffer = tryslope - .6;

        const shouldPivot = tryslope == 0 && nextDotDeg < 360 && nextDotDeg > 359;
        if (shouldPivot || tryslope >= nextDotDeg && linebuffer < nextDotDeg) {
          setpos(line, nextDot.x, nextDot.y);
          nextDot.ref.className = "hit";
          if (navigator.vibrate) {
            navigator.vibrate([100])
          }
          const p1 = getpos(line);
          let pdiff = 0;
          digs = [];
          Object.values(dots).forEach(p2 => {
            if (p1.x == p2.x && p1.y == p2.y) {

            } else {
              let pointDegs = Math.atan2((p2.y * -1) - (p1.y * -1), p2.x - p1.x) * 180 / Math.PI;
              if (pointDegs < 0) {
                pointDegs = 360 + pointDegs;
              }
              digs.push({
                d: pointDegs,
                p: p2
              });
            }

          });
          digs.sort((a, b) => a.d - b.d);
          let potentialdig = 'false';
          let potentialdot = 'false';
          let pdig;
          let pdot;
          for (const dig of digs) {
            if (slope < dig.d) {
              potentialdig = dig.d;
              potentialdot = dig.p;
              break;
            }
          }

          if (potentialdig === 'false' && digs[0]) {
            pdig = digs[0].d
            pdot = digs[0].p;
          } else {
            pdig = potentialdig
            pdot = potentialdot;
          }


          let islope = slope + 180;
          if (islope < 0) {
            islope = 360 + islope;
          } else if (islope > 360) {
            islope = islope - 360;
          }
          let ipotentialdig = 'false';
          let ipotentialdot = 'false';
          let ipdig;
          let ipdot;
          for (const dig of digs) {

            if (islope < dig.d) {
              ipotentialdig = dig.d;
              ipotentialdot = dig.p;
              break;
            }
          }

          if (ipotentialdig === 'false' && digs[0]) {
            ipdig = digs[0].d
            ipdot = digs[0].p;
          } else {
            ipdig = ipotentialdig
            ipdot = ipotentialdot;
          }
          let sdif = (pdig - slope < 0) ? pdig + (360 - slope) : pdig - slope;
          let isdif = (ipdig - islope < 0) ? ipdig + (360 - islope) : ipdig - islope;

          if (sdif > isdif) {
            nextDotDeg = ipdig;
            nextDot = ipdot;
            shouldUseislope = true;
          } else {
            nextDotDeg = pdig;
            nextDot = pdot;
            shouldUseislope = false;
          }



          console.log({
            nextDotDeg,
            nextDot,
            shouldUseislope,
            slope,
            islope,
          })

        }
        line.style.transform = `rotate(${ 360 - slope}deg)`;
        slope = slope + 0.5;
        if (slope === 360) {
          slope = 0;
        }
      }

      function step(timestamp) {
        if (!start) start = timestamp;
        var progress = timestamp - start;
        doStuff();
        window.requestAnimationFrame(step);
        /* if (progress < dkwtd) {
           window.requestAnimationFrame(step);
         } */
      }

      window.requestAnimationFrame(step);


      const makeDot = (parent, x, y) => {
        const newDot = document.createElement("div");
        newDot.style.left = `${x}px`;
        newDot.style.top = `${y}px`;
        newDot.className = "dot";
        parent.appendChild(newDot);
        dots[`${x},${y}`] = {
          x,
          y,
          ref: newDot
        }
        console.log({
          dots
        });
        const p1 = getpos(line);
        let pdiff = 0;
        digs = [];
        Object.values(dots).forEach(p2 => {
          if (p1.x == p2.x && p1.y == p2.y) {

          } else {
            let pointDegs = Math.atan2((p2.y * -1) - (p1.y * -1), p2.x - p1.x) * 180 / Math.PI;
            if (pointDegs < 0) {
              pointDegs = 360 + pointDegs;
            }
            digs.push({
              d: pointDegs,
              p: p2
            });
          }

        });
        digs.sort((a, b) => a.d - b.d);
        let potentialdig = 'false';
        let potentialdot = 'false';
        let pdig;
        let pdot;
        for (const dig of digs) {
          if (slope < dig.d) {
            potentialdig = dig.d;
            potentialdot = dig.p;
            break;
          }
        }

        if (potentialdig === 'false' && digs[0]) {
          pdig = digs[0].d
          pdot = digs[0].p;
        } else {
          pdig = potentialdig
          pdot = potentialdot;
        }


        let islope = slope + 180;
        if (islope < 0) {
          islope = 360 + islope;
        } else if (islope > 360) {
          islope = islope - 360;
        }
        let ipotentialdig = 'false';
        let ipotentialdot = 'false';
        let ipdig;
        let ipdot;
        for (const dig of digs) {

          if (islope < dig.d) {
            ipotentialdig = dig.d;
            ipotentialdot = dig.p;
            break;
          }
        }

        if (ipotentialdig === 'false' && digs[0]) {
          ipdig = digs[0].d
          ipdot = digs[0].p;
        } else {
          ipdig = ipotentialdig
          ipdot = ipotentialdot;
        }
        let sdif = (pdig - slope < 0) ? pdig + (360 - slope) : pdig - slope;
        let isdif = (ipdig - islope < 0) ? ipdig + (360 - islope) : ipdig - islope;

        if (sdif > isdif) {
          nextDotDeg = ipdig;
          nextDot = ipdot;
          shouldUseislope = true;
        } else {
          nextDotDeg = pdig;
          nextDot = pdot;
          shouldUseislope = false;
        }


        console.log({
          nextDotDeg,
          nextDot,
          shouldUseislope,
          slope,
          islope,
        })
      }

      var iOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);

      const clickOrTap = (event) => {
        makeDot(universe, event.clientX || event.pageX, event.clientY || event.pageY);
      }

      var clickortouch = (iOS && 'ontouchstart' in window) ? 'touchstart' : 'click';
      document.addEventListener(clickortouch, clickOrTap);

    </script>

    <!-- Default Statcounter code for Windmill Simulation
https://aalluri7.github.io/windmill/ -->
    <script type="text/javascript">
      var sc_project = 12110059;
      var sc_invisible = 1;
      var sc_security = "eebfd5b0";

    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <!-- End of Statcounter Code -->
  </body>

</html>
